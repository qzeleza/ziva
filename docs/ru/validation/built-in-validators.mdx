---
title: "Встроенные валидаторы"
description: "Какие проверки доступны из коробки и как их подключать"
---

# Встроенные валидаторы

Ziva поставляется с фабрикой валидаторов `ziva.DefaultValidators`. Все методы возвращают готовый объект, который можно передать в `InputTask.WithValidator()`.

```go
v := ziva.DefaultValidators
input := ziva.NewInputTask("Email", "Укажите адрес:").
    WithValidator(v.Email())
```

## Базовые проверки

| Метод | Назначение |
| --- | --- |
| `Required()` | Строка не должна быть пустой (учитывает пробелы) |
| `MinLength(n)` | Минимальная длина строки |
| `MaxLength(n)` | Максимальная длина строки |
| `Length(n)` | Ровно `n` символов |
| `Range(min, max)` | Число в диапазоне `min..max` (целое) |

## Форматные проверки

| Метод | Назначение |
| --- | --- |
| `Email()` | Корректный email-адрес |
| `OptionalEmail()` | Email или пустая строка |
| `Username()` | 3–32 символа, латиница, цифры, подчёркивания |
| `AlphaNumeric()` | Только буквы и цифры |
| `Path()` | Путь без запрещённых символов (`<>:"|?*`) |
| `URL()` | URL, начинающийся с `http://` или `https://` |

## Сетевые проверки

| Метод | Назначение |
| --- | --- |
| `IP()` | IP-адрес (IPv4 или IPv6) |
| `IPv4()` | Только IPv4 |
| `IPv6()` | Только IPv6 |
| `Domain()` | Доменное имя (RFC 1035) |
| `Port()` | Порт `1..65535` |
| `HTTPPort()` | То же, что `Port()`, но удобно для читаемости кода |

## Пароли

| Метод | Назначение |
| --- | --- |
| `StandardPassword()` | Минимум 8 символов, без кириллицы, с цифрами и спецсимволами |
| `StrongPassword()` | Минимум 12 символов, требуется смешанный набор символов |

## Примеры

```go
v := ziva.DefaultValidators

// Имя пользователя: обязательно, 3-20 символов, допустимые символы — как в `Username`
login := ziva.NewInputTask("Логин", "Введите имя:").
    WithValidator(v.Username())

// Опциональный email
supportEmail := ziva.NewInputTask("Доп. email", "Можно пропустить")
   .WithAllowEmpty(true)
   .WithValidator(v.OptionalEmail())

// Номер порта
port := ziva.NewInputTask("Порт", "1-65535:").
    WithInputType(ziva.InputTypeNumber).
    WithValidator(v.Port())
```

## Комбинирование

Если требуется несколько условий, используйте последовательную проверку внутри `FuncTask` или собственного валидатора:

```go
type composite struct{
    validators []interface{ Validate(string) error; Description() string }
}

func (c composite) Validate(input string) error {
    for _, v := range c.validators {
        if err := v.Validate(input); err != nil {
            return err
        }
    }
    return nil
}

func (c composite) Description() string {
    parts := make([]string, len(c.validators))
    for i, v := range c.validators {
        parts[i] = v.Description()
    }
    return strings.Join(parts, "; ")
}

value := ziva.NewInputTask("Сервисный ID", "Введите код:")
value.WithValidator(composite{validators: []interface{
    Validate(string) error
    Description() string
}{
    v.Required(),
    v.AlphaNumeric(),
    v.Length(10),
}})
```

<Warning>
Следите за сообщениями об ошибках. Если валидаторов много, объединяйте их описание вручную, чтобы не перегружать пользователя.
</Warning>

## Когда использовать кастомные валидаторы

- Форма требует специфических правил (например, check-sum, внешних сервисов).
- Необходимо разное поведение в зависимости от контекста.
- Нужно переиспользовать одну и ту же проверку в нескольких задачах.

Читайте про создание собственных валидаторов в разделе [Кастомные валидаторы](/ru/validation/custom-validators).
