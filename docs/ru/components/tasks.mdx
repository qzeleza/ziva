---
title: "Обзор задач"
description: "Какие типы задач доступны в Ziva и как с ними работать"
---

# Типы задач Ziva

Ziva предоставляет пять готовых типов задач. Каждая из них решает конкретный сценарий пользовательского ввода и интегрируется в очередь без ручного управления состоянием.

<CardGroup cols={2}>
  <Card title="YesNoTask" icon="check-circle" href="/ru/components/yesno-task">
    Быстрый бинарный выбор (Да/Нет) с поддержкой таймаута
  </Card>
  <Card title="SingleSelectTask" icon="mouse-pointer" href="/ru/components/singleselect-task">
    Выбор одного варианта из списка с подсказками и отключением пунктов
  </Card>
  <Card title="MultiSelectTask" icon="list-check" href="/ru/components/multiselect-task">
    Множественный выбор с пунктом «Выбрать все» и предзаполненными значениями
  </Card>
  <Card title="InputTask" icon="keyboard" href="/ru/components/input-task">
    Текстовый ввод с типами полей, таймаутами и встроенной валидацией
  </Card>
  <Card title="FuncTask" icon="play" href="/ru/components/func-task">
    Запуск произвольной функции с отображением прогресса и сводки
  </Card>
</CardGroup>

## Общие возможности

### Таймауты

Каждая задача поддерживает таймаут с автоматическим значением по умолчанию:

```go
task.WithTimeout(5*time.Second, fallbackValue)
```

Укажите fallback так, чтобы он соответствовал типу задачи (строка, индекс, `[]string`, `bool` и т.д.). YesNoTask также предоставляет специальные методы `WithTimeoutYes()` / `WithTimeoutNo()`.

### Подсказки и разделители

В списковых задачах можно добавлять вспомогательный текст через разделитель (по умолчанию `::`). Новый разделитель задаётся глобально:

```go
ziva.SetChoiceHelpDelimiter(" → ")
```

### Отключение элементов

`SingleSelectTask` и `MultiSelectTask` умеют блокировать пункты по значению, индексу или списку:

```go
selector.WithItemsDisabled([]string{"beta", "legacy"})
```

### Viewport

Для длинных списков ограничьте видимую часть:

```go
selector.WithViewport(7, true) // 7 элементов на экране + счётчики
```

### Хранение результатов

После `queue.Run()` данные остаются в объектах задач:

```go
selectedEnv := envTask.GetSelected()
choices := multiTask.GetSelected()
confirmed := yesTask.IsYes()
inputValue := inputTask.GetValue()
```

<Info>
Не пытайтесь читать результаты внутри очереди. Дождитесь окончания `Run()` и работайте с сохранёнными ссылками на задачи.
</Info>

## Реализация собственного типа задачи

`ziva.Task` — это алиас интерфейса `common.Task`. Если встроенных типов недостаточно, можно реализовать его самостоятельно:

```go
type customTask struct {
    task.BaseTask // используйте составление, чтобы получить готовые вспомогательные методы
}

func (t *customTask) Title() string                 { return "Моя задача" }
func (t *customTask) Run() tea.Cmd                  { return nil }
func (t *customTask) Update(msg tea.Msg) (ziva.Task, tea.Cmd) { return t, nil }
func (t *customTask) View(width int) string         { return "" }
func (t *customTask) IsDone() bool                  { return true }
func (t *customTask) FinalView(width int) string    { return t.View(width) }
func (t *customTask) HasError() bool                { return false }
func (t *customTask) Error() error                  { return nil }
func (t *customTask) StopOnError() bool             { return false }
func (t *customTask) SetStopOnError(bool)           {}
func (t *customTask) WithNewLinesInErrors(bool) ziva.Task { return t }
```

Практика показывает, что в большинстве случаев достаточно комбинации стандартных задач и `FuncTask` для побочных действий.

## Шаблон структуры приложения

```go
queue := ziva.NewQueue("Настройка кластера")

confirm := ziva.NewYesNoTask("Подтверждение", "Продолжить?")
mode    := ziva.NewSingleSelectTask("Режим", modes)
features := ziva.NewMultiSelectTask("Фичи", featureList)
name     := ziva.NewInputTask("Имя", "Введите имя кластера")
build    := ziva.NewFuncTask("Сборка", assembleCluster)

queue.AddTasks(confirm, mode, features, name, build)
if err := queue.Run(); err != nil {
    log.Fatal(err)
}

if confirm.IsYes() {
    deploy(mode.GetSelected(), features.GetSelected(), name.GetValue())
}
```

## Лучшие практики

- **Группируйте задачи по смыслу.** Пользователю проще пройти несколько небольших очередей, чем одну огромную.
- **Используйте таймауты аккуратно.** Всегда выбирайте fallback, безопасный для вашей системы.
- **Показывайте подсказки.** Разделитель помогает объяснить значения вроде `prod`, `staging`, `cli`.
- **Не дублируйте вывод.** Ziva сам управляет TUI-рендерингом; избегайте `fmt.Println` внутри задач.
- **Сохраняйте ссылки на задачи.** Это единственный способ получить результаты после завершения очереди.

Продолжайте с подробным описанием конкретных задач в соответствующих разделах.
