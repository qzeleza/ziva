---
title: "Очередь задач (Queue)"
description: "Как управлять последовательностью задач в Termos и настраивать поведение очереди"
---

# Очередь задач (Queue)

`Queue` — центральный оркестратор Termos. Он последовательно запускает задачи, управляет отображением статусов и обеспечивает единый цикл ввода/вывода в терминале.

## Создание и запуск

```go
queue := termos.NewQueue("Развертывание MyApp")

queue.AddTasks(
    termos.NewYesNoTask("Подтверждение", "Начать установку?"),
    termos.NewSingleSelectTask("Выбор среды", []string{"dev", "staging", "prod"}),
)

if err := queue.Run(); err != nil {
    log.Fatal(err)
}
```

![Скриншот: итоговая сводка очереди](/images/pic_5.png)

<Info>
Сохраняйте ссылки на созданные задачи, если нужно считать их результат после `Run()`.
</Info>

## Добавление задач

```go
queue.AddTasks(task1)                 // одиночная задача
queue.AddTasks(task1, task2, task3)   // несколько задач сразу
queue.AddTasks(task1).AddTasks(task2) // цепочка вызовов
```

Задачи запускаются в том порядке, в котором были добавлены. Повторно использовать одну и ту же очередь не рекомендуется — создавайте новую под каждый сценарий.

## Настройка отображения

### Имя приложения и заголовок

```go
queue.
  WithAppName("Deploy CLI").              // надпись в шапке
  WithAppNameColor(termos.BlueBright, true).
  WithTitleColor(termos.GreenBright, false)
```

Для цветов используйте функции `lipgloss.Color()` либо готовые константы Termos (`termos.BlueBright`, `termos.GrayDark` и т.д.).

### Нумерация задач

```go
queue.WithTasksNumbered(false, "[%02d]") // [01], [02], ... без сохранения исходного символа
queue.WithTasksNumbered(true, "(%d)")    // (1), (2), ... первый символ формата сохраняется
```

Первый параметр (`keepFirstSymbol`) определяет, нужно ли сохранять символ завершения (`✔`, `✗`) для первой задачи. Формат — любая строка для `fmt.Sprintf`.

### Сводка и разделительные линии

```go
queue.WithOutSummary(true)   // убрать финальный блок-резюме
queue.WithOutResultLine()    // отключить разделительные линии перед результатами задач
```

Даже при отключенной сводке статусы задач и их результаты остаются доступными прямо в выводе.

### Очистка экрана

```go
queue.WithClearScreen(true) // очистка терминала перед запуском очереди
```

Полезно, если приложение должно стартовать «с чистого листа». Для встроенных устройств, наоборот, часто удобно оставить вывод предыдущих команд.

## Чтение результатов задач

```go
yesno := termos.NewYesNoTask("Подтверждение", "Продолжить?")
choice := termos.NewSingleSelectTask("Выберите среду", envs)

queue := termos.NewQueue("Демо")
queue.AddTasks(yesno, choice)
_ = queue.Run()

if yesno.IsYes() {
    fmt.Printf("Среда: %s\n", choice.GetSelected())
}
```

Данные хранятся внутри объектов задач. Вам не нужно передавать дополнительные колбэки — достаточно доступа к экземплярам.

## Обработка ошибок и отмены

- Пользователь может прервать очередь (`Ctrl+C`). В этом случае `Run()` вернёт ошибку, которую можно обработать.
- Используйте `FuncTask.WithStopOnError(true)`, чтобы оборвать очередь при сбое важной операции.
- Для дружелюбного вывода сообщений об ошибке изменяйте глобальные цвета через `termos.SetErrorColor()`.

## Производительность и ресурсы

Termos содержит встроенные механизмы контроля памяти. Их удобно конфигурировать через переменные окружения:

```bash
export TERMOS_MAX_COMPLETED_TASKS=10          # лимит хранения завершённых задач
export TERMOS_MEMORY_PRESSURE_THRESHOLD=80M  # порог очистки кэша
```

Для сред с ограниченными ресурсами:

```go
termos.AutoConfigure()     // единоразовая автоконфигурация
termos.EnableEmbeddedMode() // упрощённая цветовая схема и макет
```

## Лучшие практики

- **Минимизируйте побочные эффекты в задачах.** Пусть каждая задача отвечает только за свой ввод/вывод.
- **Готовьте данные заранее.** Формируйте списки вариантов и дефолтные значения до создания задач.
- **Логируйте за пределами очереди.** Queue управляет только TUI. Используйте отдельные журналы для внутреннего состояния приложения.
- **Сохраняйте результаты.** После `Run()` извлеките значения и сохраните их в собственных структурах, пока пользователь помнит контекст.
- **Разделяйте сценарии.** Лучше несколько небольших очередей, чем одна гигантская — пользователю проще ориентироваться.

## Связанные материалы

- [Типы задач](/ru/components/tasks)
- [Настройка цветов и стилей](/ru/customization/colors)
- [Оптимизация под встроенные системы](/ru/customization/embedded-systems)
