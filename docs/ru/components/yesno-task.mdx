---
title: "YesNoTask"
description: "Бинарный выбор с таймаутами и настройкой поведения"
---

# YesNoTask

`YesNoTask` решает типичный сценарий подтверждения: «Да» или «Нет». Задача построена поверх `SingleSelectTask`, поэтому наследует часть его возможностей (дефолтные значения, таймауты, подсказки), но скрывает лишние детали.

## Создание

```go
task := termos.NewYesNoTask("Подтверждение", "Запустить обновление?")
```

Добавьте задачу в очередь и запустите её так же, как любой другой элемент:

```go
queue := termos.NewQueue("Обновление")
queue.AddTasks(task)
_ = queue.Run()
```

## Получение результата

```go
if task.IsYes() {
    fmt.Println("Пользователь подтвердил действие")
}

switch task.GetSelectedOption() {
case termos.YesOption:
    // логика для "Да"
case termos.NoOption:
    // логика для "Нет"
}
```

## Значения по умолчанию

### Языко-независимые методы

```go
task.WithDefaultYes() // подсветить «Да»
task.WithDefaultNo()  // подсветить «Нет»
```

### Универсальный метод

```go
task.WithDefaultItem(termos.YesOption)
task.WithDefaultItem(true)          // эквивалентно YesOption
task.WithDefaultItem("Нет")         // строковое совпадение без учёта регистра
```

## Таймауты

```go
task.WithTimeoutYes(5 * time.Second) // через 5 секунд автоматически выбрать «Да»
task.WithTimeoutNo(10 * time.Second) // автоматический «Нет»

// Комбинированные методы
task.WithDefaultYesAndTimeout(3 * time.Second)
task.WithDefaultNoAndTimeout(7 * time.Second)
```

Если нужен кастомный вариант:

```go
task.WithTimeout(8*time.Second, termos.NoOption)
task.WithTimeout(8*time.Second, false)
task.WithTimeout(8*time.Second, "да")
```

## Кастомные подписи

```go
task.WithCustomLabels("Продолжить", "Отменить")
```

<Note>
Текст кнопок обновляется сразу, поэтому добавляйте кастомные лейблы до передачи задачи в очередь.
</Note>

## Обработка выбора «Нет»

Termos считает вариант «Нет» условной ошибкой, чтобы очередь могла отобразить его в отчёте. При этом выполнение не прерывается. Это поведение удобно для отчётов — пользователь всегда видит, что именно он отклонил.

```go
if task.IsNo() {
    // можно вынести повторный запрос или запись в лог
}
```

## Пример: гарантированное подтверждение

```go
func mustConfirm(title, question string, timeout time.Duration) bool {
    confirm := termos.NewYesNoTask(title, question).
        WithDefaultNo().
        WithTimeoutYes(timeout) // по истечении времени всё равно продолжим

    queue := termos.NewQueue(title)
    queue.AddTasks(confirm)
    _ = queue.Run()

    return confirm.IsYes()
}
```

## Советы

- Используйте `WithTimeoutYes/No`, если интерфейс должен идти дальше без участия пользователя.
- При смене языка UI (через `termos.SetLanguage`) выбирайте языко-независимые методы — строковые значения могут не совпасть.
- Сохраняйте ссылку на задачу. Результат доступен только после `queue.Run()`.
- Для повторного запроса создайте новую очередь, чтобы не смешивать вывод.

## Связанные материалы

- [SingleSelectTask](/ru/components/singleselect-task) — общие возможности списковых задач
- [FuncTask](/ru/components/func-task) — полезно для действий после подтверждения
