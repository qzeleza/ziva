---
title: "Validation Showcase"
description: "Rich input flows with built-in and custom validators"
---

# Validation Showcase

This guide demonstrates how to build reliable forms with Termos: cover every built-in validator, assemble validation chains, and plug in external checks.

## Queue with all built-in validators

```go
func ShowBuiltInValidators() {
    v := termos.DefaultValidators

    tasks := []termos.Task{
        termos.NewInputTask("Name", "Required field:").
            WithValidator(v.Required()),

        termos.NewInputTask("Username", "3-20 characters, latin/number:").
            WithValidator(v.Username()),

        termos.NewInputTask("Short description", "Up to 40 characters:").
            WithValidator(v.MaxLength(40)),

        termos.NewInputTask("Comment", "At least 5 characters:").
            WithValidator(v.MinLength(5)),

        termos.NewInputTask("Code", "Exactly 8 characters:").
            WithValidator(v.Length(8)),

        termos.NewInputTask("Email", "Email address:").
            WithInputType(termos.InputTypeEmail).
            WithValidator(v.Email()),

        termos.NewInputTask("Website", "URL (optional):").
            WithValidator(v.OptionalURL()),

        termos.NewInputTask("IP", "IPv4 or IPv6:").
            WithInputType(termos.InputTypeIP).
            WithValidator(v.IP()),

        termos.NewInputTask("Domain", "Domain name:").
            WithInputType(termos.InputTypeDomain).
            WithValidator(v.Domain()),

        termos.NewInputTask("Port", "Range 1-65535:").
            WithInputType(termos.InputTypeNumber).
            WithValidator(v.Port()),

        termos.NewInputTask("Number", "Range 1-100:").
            WithInputType(termos.InputTypeNumber).
            WithValidator(v.Range(1, 100)),

        termos.NewInputTask("Alphanumeric", "Letters and digits only:").
            WithValidator(v.AlphaNumeric()),

        termos.NewInputTask("Password", "Minimum 8 characters:").
            WithInputType(termos.InputTypePassword).
            WithValidator(v.StandardPassword()),

        termos.NewInputTask("Strong password", "Minimum 12 characters, mixed set:").
            WithInputType(termos.InputTypePassword).
            WithValidator(v.StrongPassword()),
    }

    queue := termos.NewQueue("Validation tour").
        WithTasksNumbered(true, "[%02d]")
    queue.AddTasks(tasks...)
    _ = queue.Run()
}
```

<Info>
Each task triggers its validator after the user presses <kbd>Enter</kbd>. When validation fails, the TUI shows the error and keeps the task focused until the value matches the rules.
</Info>

## Custom validation chain

```go
type Chain struct {
    validators []termos.Validator
}

func (c Chain) Validate(input string) error {
    for _, validator := range c.validators {
        if err := validator.Validate(input); err != nil {
            return err
        }
    }
    return nil
}

func (c Chain) Description() string {
    parts := make([]string, len(c.validators))
    for i, validator := range c.validators {
        parts[i] = validator.Description()
    }
    return strings.Join(parts, "; ")
}

func AskSecureToken() {
    v := termos.DefaultValidators

    token := termos.NewInputTask(
        "API token",
        "Required, 16-64 characters, alphanumeric",
    ).WithValidator(Chain{
        validators: []termos.Validator{
            v.Required(),
            v.MinLength(16),
            v.MaxLength(64),
            v.AlphaNumeric(),
        },
    })

    queue := termos.NewQueue("Token validation")
    queue.AddTasks(token)
    _ = queue.Run()

    fmt.Println("Token accepted:", token.GetValue())
}
```

## External validator example

```go
func emailNotInCRM(email string) bool {
    // Replace with actual API call.
    return !strings.HasSuffix(email, "@banned.example")
}

type UniqueEmail struct{}

func (UniqueEmail) Validate(input string) error {
    if !emailNotInCRM(input) {
        return errors.New("email is already registered")
    }
    return nil
}

func (UniqueEmail) Description() string {
    return "Email must be unique in CRM"
}

func SignUpForm() error {
    v := termos.DefaultValidators

    email := termos.NewInputTask("Email", "Enter work email:").
        WithInputType(termos.InputTypeEmail).
        WithValidator(v.Email())

    password := termos.NewInputTask(
        "Password",
        "Minimum 12 characters, letters/digits/symbols",
    ).WithInputType(termos.InputTypePassword).
        WithValidator(v.StrongPassword())

    confirm := termos.NewYesNoTask(
        "Confirmation",
        "Submit data to CRM?",
    ).WithDefaultYes()

    queue := termos.NewQueue("User signup")
    queue.AddTasks(email, password, confirm)
    if err := queue.Run(); err != nil {
        return err
    }

    check := termos.NewInputTask("Uniqueness check", "Email must be unique:").
        WithInputType(termos.InputTypeEmail).
        WithValidator(UniqueEmail{})

    followUp := termos.NewQueue("CRM check")
    followUp.AddTasks(check)
    return followUp.Run()
}
```

<Note>
Use a `FuncTask` after collecting input if you need to call an external service and display the outcome (success, warning, retry hints) inside the TUI.
</Note>

## Quick tips

- Keep `Description()` human-friendly — Termos shows it near the input field.
- Combine `WithAllowEmpty(true)` with validators that handle empty strings correctly.
- Break long forms into several queues; it simplifies returning to the problem field.
- Write unit tests for elaborate validators — they are plain Go code.

Head over to the best practices page to see how these building blocks fit together in real projects.
