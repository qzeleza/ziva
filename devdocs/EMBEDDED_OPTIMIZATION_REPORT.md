# Руководство по оптимизации для embedded

Это руководство суммирует практические шаги для эффективной работы Термос на системах с ограниченными ресурсами (роутеры, SBC, IoT). Используются только API, реально присутствующие в репозитории.

- Цель: устройства с ≥16–32 МБ RAM, низкочастотные CPU
- Версия Go: 1.22+

> Примечание: начиная с встроенной автоконфигурации (`internal/autoconfig`), базовая адаптация под embedded активируется автоматически при импортировании модуля. Для явного управления доступны переменные окружения:
>
> - `TERMOS_EMBEDDED` — принудительно включает/выключает режим embedded (`true`/`1` или пусто/`0`).
> - `TERMOS_MEMORY_LIMIT` — задаёт порог памяти для эвристики (например: `64MB`, `128KB`, `1GB`).
> - `TERMOS_ASCII_ONLY` — форсирует ASCII-режим (`true`).

## Ширина рендера и разметка

- Используйте `common.CalculateLayoutWidth(screenWidth int) int`, чтобы ограничить ширину строк по размеру терминала.
- Используйте `common.DefaultWidth` (80) как запасной вариант, если `screenWidth` мал или неизвестен.
- Держите строки в пределах вычисленной ширины, чтобы избегать лишних переносов.

```go
w := common.CalculateLayoutWidth(120) // например, из фактической ширины терминала
view := task.View(w)
```

## Память и аллокации

Предпочитайте пуллинг буферов и эффективные хелперы из `performance/`:

- Пулы буферов:
  - `performance.GetBuffer()` / `performance.PutBuffer()` для `strings.Builder`
  - `performance.NewStringPool(size)` для собственных пулов строк
  - `performance.NewByteBufferPool(size)` для `*bytes.Buffer`
- Операции со строками (с учётом аллокаций):
  - `performance.JoinEfficient(parts, sep)`
  - `performance.RepeatEfficient(s, count)`
  - `performance.FastConcat(parts...)`
  - `performance.TrimSpaceEfficient(s)`
- Учёт длины с ANSI:
  - `performance.StripANSILength(s)` используется `ui.GetPlainTextLength`

Рекомендации:
- Переиспользуйте `strings.Builder` из пулов для построения временных UI-строк.
- Избегайте больших промежуточных строк. По возможности рендерьте построчно.
- Не возвращайте за пределы скоупа объекты из пулов.

## Безопасность ANSI/Unicode

- Выравнивание с учётом ANSI: `ui.AlignTextToRight(left, right, width)` использует ANSI-осведомлённую длину.
- Переносы и очистка:
  - `ui.StripANSI(text)`
  - `ui.WrapText(text, width)`
  - `ui.GetRuneWidth(r rune)` для широких глифов

Стабилизируйте вывод, ограничивая эмодзи/широкие символы на очень узких экранах.

## Контроль стоимости стилизации

- Переиспользуйте экспортируемые стили из `ui/styles.go`, не создавайте новые каждый кадр.
- Модифицируйте стили один раз при инициализации, а не в каждом рендере:

```go
ui.TitleStyle = ui.TitleStyle.Foreground(ui.ColorBrightGreen)
ui.SelectionNoStyle = ui.SelectionNoStyle.Bold(true)
```

- Сократите палитру при 8/16-цветных терминалах. Предпочитайте только изменения переднего плана.

## Совет по циклу Update задач

- У встроенных задач `Run()` возвращает `nil` (нет фоновых команд). Обновления UI происходят по событиям клавиатуры в `Update`.
- Избегайте активных циклов; полагайтесь на модель событий Bubble Tea. Перерисовывайте только при вводе или изменении состояния.
- Держите слайсы опций предвыделенными и избегайте частых реслайсов при навигации.

## Ошибки и сообщения

- Форматируйте многострочные ошибки через `ui.FormatErrorMessage(text, width)`, чтобы не допускать переполнений и лишних рефлоу.
- На маленьких экранах ограничивайте многословие ошибок; подробности выводите после завершения.

## Windows и варианты терминалов

- Предпочитайте современные терминалы с поддержкой ANSI (Windows Terminal, оболочки с ConPTY). Старый cmd.exe может деградировать рендеринг.
- При перенаправлении в файл учитывайте наличие ANSI; для логов используйте `ui.StripANSI`.

## Чек‑лист для embedded‑сборок

- Используйте `common.CalculateLayoutWidth` для каждого вызова `View`/`FinalView`.
- Переиспользуйте стили; избегайте их создания в каждом кадре.
- Используйте `performance.*` для join/repeat/concat.
- Применяйте пулы для временного построения строк.
- Держите внутренние слайсы предвыделенными; избегайте лишних аллокаций в `Update`.
- Ограничивайте широкие символы/эмодзи; предпочитайте ASCII на узких экранах.

## Дальнейшие шаги (заметки, не API)

- Оркестрация очередей в `query/` может координировать задачи с минимальными накладными.
- Пакет валидации сможет реализовать валидаторы без аллокаций для полей ввода.

Эти заметки не обещают несуществующие API и фокусируются на уже доступных возможностях репозитория.
